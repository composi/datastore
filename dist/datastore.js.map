{"version":3,"file":"datastore.js.map","sources":["../node_modules/@composi/get-type/src/index.js","../node_modules/@composi/merge-objects/src/index.js","../node_modules/@composi/observer/src/index.js","../src/index.js"],"sourcesContent":["/**\n * Determine the type of the provided argument.\n * @param {*} value\n * @return {string} string\n */\nexport function getType(value) {\n  // Trap for NaN:\n  if (typeof value === 'number' && isNaN(value)) {\n    return 'NaN'\n  } else {\n    return new RegExp('\\\\[object (.*)]').exec(toString.call(value))[1]\n  }\n}\n","/**\n * Combine two objects, merging the second into the first. Any properties already existing in the first will be replaced by those of the second. Any properties in the second not in the first will be added to it.\n * This does a deep clone. Sub arrays will be cloned. If arrays consist of objects, those will be cloned. Functions will also be cloned.\n * Passing in just one object will return a deep clone of it.\n *\n * @param {Object.<string, any>[]} objects\n * @return {Object.<string, any>} Object.<string, any>\n */\n\nexport function mergeObjects(...objects) {\n  // Add empty object to arguments.\n  // This insures the result is a clone.\n  objects.unshift({})\n\n  /**\n   * Merge on object into another.\n   * @param {Object<string, any>} target\n   * @param {Object<string, any>} source\n   */\n  function createClone(target, source) {\n    for (let key in source) {\n      let descriptor = Object.getOwnPropertyDescriptor(source, key)\n      if (descriptor.value instanceof String) {\n        target[key] = new String(descriptor.value)\n      } else if (descriptor.value instanceof Array) {\n        target[key] = createClone([], descriptor.value)\n      } else if (descriptor.value instanceof Function) {\n        target[key] = descriptor.value\n      } else if (descriptor.value instanceof Object) {\n        let prototype = Reflect.getPrototypeOf(descriptor.value)\n        let clonedObject = createClone({}, descriptor.value)\n        Reflect.setPrototypeOf(clonedObject, prototype)\n        target[key] = clonedObject\n      } else {\n        Object.defineProperty(target, key, descriptor)\n      }\n    }\n\n    let prototype = Reflect.getPrototypeOf(source)\n    Reflect.setPrototypeOf(target, prototype)\n    return target\n  }\n  // Return cloned copy of merged objects:\n  return objects.reduce((a, b) => createClone(a, b))\n}\n","/**\n * Observer class providing two methods: watch and dispatch.\n * It also exposes a method for setting state: `setState`.\n * `setState` works just like the same method on Composi class components.\n * When you use `setState` it sends a message to an instance of DataStoreComponent to update itself.\n */\nexport class Observer {\n  constructor() {\n    this.events = {}\n  }\n\n  /**\n   * Method to subscribe to a publishing event.\n   * @param {string} event\n   * @param {Function} callback\n   * @return {Object.<string, any>} events\n   */\n  watch(event, callback) {\n    this.events[event] = []\n    return this.events[event].push(callback)\n  }\n\n  /**\n   *\n   * @param {string} event\n   * @param {any} [data]\n   * @return {any[]} events\n   */\n  dispatch(event, data) {\n    // There's no event to dispatch to, so bail out:\n    if (!this.events.hasOwnProperty(event)) {\n      return []\n    }\n    return this.events[event].map(callback => callback(data))\n  }\n\n  /**\n   * Remove an event from queue.\n   * @param {string} event\n   * @return {void} undefined\n   */\n  unwatch(event) {\n    this.events[event]\n  }\n}\n","import { getType } from '@composi/get-type'\nimport { mergeObjects } from '@composi/merge-objects'\nconst EMPTY_OBJECT = {}\nimport { Observer } from '@composi/observer'\n\n/**\n * A uuid to use as the property of the dataStore's state. This creates a pseudo-private\n */\nconst dataStore = Symbol()\n\n/**\n * A class to create a dataStore. This is used in conjunction with DataStoreComponent to create stateless components with external state management through a dataStore.\n */\nexport class DataStore {\n  constructor(props) {\n    this[dataStore] = undefined\n    this.observer = new Observer()\n    this.state = props.state\n    this.events = {}\n    this.events['dataStoreStateChanged'] = []\n    if (props.event) {\n      this.events[props.event] = []\n    }\n  }\n\n  /**\n   * @method This is a getter to access the component's state using the pseudo-private key dataStore.\n   * @return {boolean | number | string | Object | any[]} The component's state\n   */\n  get state() {\n    return this[dataStore]\n  }\n\n  /**\n   * @method This is a setter to define the component's state. It uses the dataStore object as a pseudo-private key. It uses requestAnimationFrame to throttle component updates to avoid layout thrashing.\n   * @param {string | number | boolean | Object | any[]} data Data to set as component state.\n   * @return {void} undefined\n   */\n  set state(data) {\n    this[dataStore] = data\n    if (this.events) {\n      Object.keys(this.events).map(event => {\n        if (event.length) {\n          this.dispatch(event, this.state)\n        }\n      })\n    }\n  }\n\n  /**\n   * @method This is a method to dispatch an event with data to a DataStoreComponent that is using a dataStore.\n   * @param {string} event The name of the event that the component is watching.\n   * @param {any} data Any data you want to send to the component.\n   */\n  dispatch(event, data) {\n    if (!event) {\n      this.observer.dispatch('dataStoreStateChanged', data)\n      this.observer.dispatch(event, data)\n    } else {\n      this.observer.dispatch(event, data)\n    }\n  }\n\n  /**\n   * @method This method sets up an observer to listener for the designated event and do something with any data passed along.\n   * @param {string} event The event to watch.\n   * @param {any} cb Any data that the event callback will need to handle.\n   */\n  watch(event, cb) {\n    if (typeof event === 'string') {\n      this.events[event] = [this.observer.watch(event, cb)]\n    } else {\n      this.events['dataStoreStateChanged'].push(\n        this.observer.watch('dataStoreStateChanged', event)\n      )\n    }\n  }\n\n  /**\n   * @method Method to set a dataStore's state. This accepts simple types or Objects. If updating an array, you can pass in the data and the position (number) in the array to update. Optionally you can pass a callback, which receives the state as its argument. You need to return the state changes in order for the component to be updated.\n   * @example Set state on a dataStore:\n   * \n   * ```\n   * this.setState(true)\n   * this.setState(0)\n   * this.setState({name: 'Joe'})\n   * this.setState([1,2,3])\n   * this.setState(prevState => prevState + 1)\n   ```\n   * @param {string | number | boolean | Object | any[] | Function} data The data to set. If a callback is passed as the argument to execute, it gets passed the previous state as its argument. You need to make sure the callback returns the final state or the component will not update.\n   * @return {void} undefined\n   */\n  setState(data) {\n    if (typeof data === 'function') {\n      let copyOfState\n      if (getType(this.state) === 'Array') {\n        copyOfState = JSON.parse(JSON.stringify(this.state))\n      } else if (typeof this.state === 'object') {\n        copyOfState = mergeObjects(EMPTY_OBJECT, this.state)\n      } else {\n        // Handle primitive types:\n        copyOfState = this.state\n      }\n      const newState = data.call(this, copyOfState)\n      if (newState) this.state = newState\n    } else if (getType(this.state) === 'Object' && getType(data) === 'Object') {\n      const newState = mergeObjects(this.state, data)\n      this.state = newState\n    }\n  }\n\n  /**\n   * Unwatch a custom event. This will not remove the default event--dataStoreStateChanged.\n   * @param {string} event\n   * @return {void} undefined\n   */\n  unwatch(event) {\n    if (event !== 'dataStoreStateChanged') {\n      delete this.events[event]\n    }\n  }\n}\n"],"names":["getType","value","isNaN","exec","toString","call","mergeObjects","objects","createClone","target","source","key","descriptor","Object","getOwnPropertyDescriptor","String","Array","Function","prototype","Reflect","getPrototypeOf","clonedObject","setPrototypeOf","defineProperty","unshift","reduce","a","b","Observer","constructor","events","watch","event","callback","push","dispatch","data","hasOwnProperty","map","unwatch","EMPTY_OBJECT","dataStore","Symbol","DataStore","props","observer","state","cb","copyOfState","JSON","parse","stringify","_typeof","newState","keys","length","_this"],"mappings":"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"}